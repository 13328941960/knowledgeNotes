(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{229:function(t,_,a){"use strict";a.r(_);var v=a(6),s=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"网络协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络协议"}},[t._v("#")]),t._v(" 网络协议")]),t._v(" "),_("h2",{attrs:{id:"协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[t._v("#")]),t._v(" 协议")]),t._v(" "),_("p",[t._v("双方通信计算机的时候，需要遵循一定的规则。就像人交流的时候，需要先规定好一种语言。这样的交流规则就是协议")]),t._v(" "),_("h2",{attrs:{id:"tcp三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[t._v("#")]),t._v(" TCP三次握手")]),t._v(" "),_("ol",[_("li",[t._v("刚开始客户端处于closed状态，服务端处于listen状态")]),t._v(" "),_("li",[t._v("第一次握手：客户端给服务端发送一个SYN报文，并指明客户端初始序列号。此时客户端处于SYN_SEND状态。")]),t._v(" "),_("li",[t._v("第二次握手：服务端收到客户端的SYN报文后，发送一个以客户端的SYN + 1作为序列号值的ACK报文，表示自己已经收到客户端的SYN，同时发送自己的SYN报文，并指定自己的初始序列号ISN(s), 此时服务端处于SYN_REVD的状态")]),t._v(" "),_("li",[t._v("第三次握手：客户端收到服务端发来的SYN+ACK报文后，发送一个以服务端的SYN+1作为序列号值的ACK报文，表示已经收到了服务端的SYN+ACK报文，此时客户端处于establised状态")]),t._v(" "),_("li",[t._v("服务端收到ACK报文后也处于establised状态，此时双方建立起了链接。")])]),t._v(" "),_("h2",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),_("ol",[_("li",[t._v("刚开客户端和服务端都处于establised状态")]),t._v(" "),_("li",[t._v("第一次挥手，客户端先发送一个FIN报文，报文中初始一个序列号。此时客户端处于time_wait1状态")]),t._v(" "),_("li",[t._v("第二次挥手，服务端收到FIN报文后，服务端收到后返回一个以FIN+1为序列号的ACK报文，表示已经收到客户端发来的FIN报文。此时服务端处于closed_wait状态")]),t._v(" "),_("li",[t._v("第三次挥手，服务端也发送一个FIN报文，并且在报文中初始话一个序列号，此时服务端处于Last_ack状态。")]),t._v(" "),_("li",[t._v("第四次挥手，客户端收到服务端发来的FIN报文，返回一个以FIN+1为序列号的Ack报文，表示已经接收到服务端发来的FIN报文。此时客户端处于time_wait状态。\n需要等一段报文来回传输的时间后，来确保服务端收到自己的ACK报文之后才会进入close状态。")]),t._v(" "),_("li",[t._v("服务端收到了ACK后，就处于close状态了")])]),t._v(" "),_("h2",{attrs:{id:"三次握手的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手的作用"}},[t._v("#")]),t._v(" 三次握手的作用")]),t._v(" "),_("ol",[_("li",[t._v("确认双方的发送能力和接受能力是否正常")]),t._v(" "),_("li",[t._v("为后续的可靠传输做准备")])]),t._v(" "),_("h2",{attrs:{id:"http-报文结构是怎样的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-报文结构是怎样的"}},[t._v("#")]),t._v(" HTTP 报文结构是怎样的")]),t._v(" "),_("p",[_("strong",[t._v("请求报文")]),t._v(" = 起始行 + 头部 + 空行 + 实体")]),t._v(" "),_("p",[_("strong",[t._v("响应报文")]),t._v(" = 起始行 + 头部 + 空行 + 实体")]),t._v(" "),_("h3",{attrs:{id:"起始行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#起始行"}},[t._v("#")]),t._v(" 起始行")]),t._v(" "),_("ol",[_("li",[t._v("请求起始行：方法 路径 版本: GET /home HTTP/1.1")])]),t._v(" "),_("p",[t._v("每个部分用空格隔开，最后加一个换行")]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("响应始行：http版本 状态 原因: HTTP/1.1 200 ok")])]),t._v(" "),_("p",[t._v("每个部分用空格隔开，最后加一个换行")]),t._v(" "),_("h3",{attrs:{id:"头部"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#头部"}},[t._v("#")]),t._v(" 头部")]),t._v(" "),_("p",[t._v("字段名：字段值 换行")]),t._v(" "),_("h3",{attrs:{id:"空行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#空行"}},[t._v("#")]),t._v(" 空行")]),t._v(" "),_("p",[t._v("很重要，用来区分开头部和实体。")]),t._v(" "),_("h3",{attrs:{id:"实体"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实体"}},[t._v("#")]),t._v(" 实体")]),t._v(" "),_("p",[t._v("就是具体的数据了，也就是body部分。请求报文对应请求体, 响应报文对应响应体。")]),t._v(" "),_("h2",{attrs:{id:"http请求方式-区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http请求方式-区别是什么"}},[t._v("#")]),t._v(" HTTP请求方式，区别是什么")]),t._v(" "),_("p",[t._v("GET: 用于获取资源\nHEAD: 获取资源的元信息\nPOST: 提交数据\nPUT: 修改数据\nDELETE: 删除数据\nCONNECT: 建立连接隧道，用于代理服务器\nOPTIONS: 列出服务允许的请求方法，用于跨域请求\nTRACE: 追求请求-响应的传输路径")]),t._v(" "),_("h2",{attrs:{id:"谈一谈http协议优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#谈一谈http协议优缺点"}},[t._v("#")]),t._v(" 谈一谈HTTP协议优缺点")]),t._v(" "),_("p",[t._v("HTTP 特点：\n一、灵活可扩展：1. 语法上只规定了基本格式：空格分隔单词，换行分隔字段等。 2. 传输形式上不仅可以传输文本、还可传输图片、视频等任意数据。")]),t._v(" "),_("p",[t._v("二、可靠传输：HTTP是基于TCP/IP的，因此把这一特性继承了下来")]),t._v(" "),_("p",[t._v("三、无状态：无状态也会减少网络开销")]),t._v(" "),_("p",[t._v("四、请求-应答模式：就是一方发送消息，另一方接受消息或者响应。")]),t._v(" "),_("p",[t._v("缺点：")]),t._v(" "),_("p",[t._v("一、无状态：有时候，网站需要保存信息，比如购物系统，需要保留下客户的信息等，但是无状态无法做到保存信息。\n二、明文传输：http报文是以文本形式传输，这让http的报文信息暴露给外界\n三、队头阻塞：当http开启长连接时，公用同一个TCP，如果有一个连接请求时间过长，其他的请求只能处于阻塞状态。那么就会造成对头阻塞")]),t._v(" "),_("h2",{attrs:{id:"http-1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" HTTP 1.1")]),t._v(" "),_("p",[t._v("HTTP 1.1")]),t._v(" "),_("ul",[_("li",[t._v("持久连接：TCP默认不关闭，可以被多个HTTP请求复用。")]),t._v(" "),_("li",[t._v("管道机制：在同一个TCP中，客户端可以发送多个HTTP请求")]),t._v(" "),_("li",[t._v("虚拟机：在一台物理机中存在多个虚拟机，共享同一个IP")]),t._v(" "),_("li",[t._v("断点续传：在请求头中设置Range")]),t._v(" "),_("li",[t._v("控制标识： E-tag/IF-None-Match, Last-Modified/IF-Unmodified-Sinced等缓存控制标识来控制缓存失效。")]),t._v(" "),_("li",[t._v("方法： PUT/PATCH/OPTIONS/DELETE方法")])]),t._v(" "),_("h2",{attrs:{id:"http-2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0"}},[t._v("#")]),t._v(" HTTP 2.0")]),t._v(" "),_("ul",[_("li",[t._v("二进制传输：将HTTP1.1的明文改为了二进制传输，头部信息称为头部信息帧，数据体称为数据帧")]),t._v(" "),_("li",[t._v("头部压缩：HTTP1.1中可能出现头部几百甚至几千字节，请求体却只有几十字节的情况，HTTP2.0对此进行改善，将头部进行压缩处理。")]),t._v(" "),_("li",[t._v("多路复用：在同一个TCP中，客户端和服务端可以发送多个HTTP请求，不会阻塞。解决了HTTP1.1中对头阻塞的问题")]),t._v(" "),_("li",[t._v("服务器推送：服务器主动推送数据，不需要客户端发起请求。")]),t._v(" "),_("li",[t._v("优先级设置：让服务器优先处理重要资源，提升用户体验。")])]),t._v(" "),_("h2",{attrs:{id:"介绍http-缓存策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍http-缓存策略"}},[t._v("#")]),t._v(" 介绍HTTP 缓存策略")]),t._v(" "),_("ol",[_("li",[t._v("检查缓存标识：当发起HTTP请求的时候，会先检查是否存在缓存结果和缓存标识")]),t._v(" "),_("li",[t._v("向服务发起请求：如果没有缓存结果和缓存标识，或者已经失效，那么就向服务器发起请求")]),t._v(" "),_("li",[t._v("强缓存：如果存在缓存结果和缓存标识，那么使用强缓存")]),t._v(" "),_("li",[t._v("协商缓存：如果缓存结果失效，但存在缓存标识，则使用协商缓存")])]),t._v(" "),_("h3",{attrs:{id:"内存缓存在哪里呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存缓存在哪里呢"}},[t._v("#")]),t._v(" 内存缓存在哪里呢？")]),t._v(" "),_("p",[t._v("先从内存中取，再从硬盘中取资源。")]),t._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("第一次发送HTTP请求，服务端会在报文中返回一个Last-Modidied 或者 Etag，Last-Modidied 是代表该资源在服务端最后修改的时间，")])]),t._v(" "),_("li",[_("p",[t._v("如果服务器返回的是Last-Modidied，客户端再次发送请求时会在请求头中放入If-Modidied-Sinced字段，If-Modidied-Sinced 是客户端记住的资源在服务端最后修改的时间，如果和Last-Modidied一致则使用协商缓存，返回的状态为304")])]),t._v(" "),_("li",[_("p",[t._v("如果服务返回的是E-tag，代表该资源的唯一标识，客户端再次发送请求时会在请求头中放入If-None-Match字段，If-None-Match 是客户端记住的资源的唯一标识，在下次发送给服务端，如果和Etag一致则使用协商缓存，返回的状态为304")])]),t._v(" "),_("li",[_("p",[t._v("Etag 优先级高于Last-Modified，同时存在则只有Etag生效。")])])]),t._v(" "),_("h2",{attrs:{id:"http状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[t._v("#")]),t._v(" Http状态码")]),t._v(" "),_("h3",{attrs:{id:"_1xx"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1xx"}},[t._v("#")]),t._v(" 1xx")]),t._v(" "),_("p",[t._v("请求正在处理")]),t._v(" "),_("h3",{attrs:{id:"_2xx-请求成功"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2xx-请求成功"}},[t._v("#")]),t._v(" 2xx：请求成功")]),t._v(" "),_("p",[t._v("200: 客户端请求被服务端成功处理并返回数据。\n204：客户端请求被服务端成功处理但未返回数据。\n206：客户端使用Content-Range进行范围请求，被服务端成功处理并返回数据。")]),t._v(" "),_("h3",{attrs:{id:"_3xx-重定向"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3xx-重定向"}},[t._v("#")]),t._v(" 3xx: 重定向")]),t._v(" "),_("p",[t._v("301：永久重定向，表示资源已经被分配了新的URL\n302：临时重定向，表示资源临时分配到了新的URL\n303：表示资源存在着另一个URL，需要用GET方法请求\n304：表示协商缓存命中时，返回该状态码\n307：临时重定向")]),t._v(" "),_("h3",{attrs:{id:"_4xx-客户端错误"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4xx-客户端错误"}},[t._v("#")]),t._v(" 4xx: 客户端错误")]),t._v(" "),_("p",[t._v("400：表示客户端请求地址或者请求参数错误\n401：表示发送的请求需要通过HTTP认证的认证信息\n403：表示请求被服务器拒绝。\n404：表示服务器没有找到该资源\n405：表示服务器不接受该请求方法")]),t._v(" "),_("h3",{attrs:{id:"_5xx-服务端错误"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5xx-服务端错误"}},[t._v("#")]),t._v(" 5xx: 服务端错误")]),t._v(" "),_("p",[t._v("500：表示服务端执行请求时发生了错误\n502：表示服务器自身正常，但访问时出问题，具体不知道是什么问题。\n503：表示服务器暂时处于超负荷或停止服务")])])}),[],!1,null,null,null);_.default=s.exports}}]);