<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>框架 | 前端知识体系</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/knowledgeNotes/favicon.ico">
    <meta name="description" content="JavaScript、浏览器、网络协议、面试题等基本知识点">
    
    <link rel="preload" href="/knowledgeNotes/assets/css/0.styles.64ebfe11.css" as="style"><link rel="preload" href="/knowledgeNotes/assets/js/app.62fdb92b.js" as="script"><link rel="preload" href="/knowledgeNotes/assets/js/2.53f1d7f8.js" as="script"><link rel="preload" href="/knowledgeNotes/assets/js/46.ccfce139.js" as="script"><link rel="prefetch" href="/knowledgeNotes/assets/js/10.7f4c0454.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/11.9b8da9ed.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/12.6aa225ce.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/13.d48e6556.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/14.f1d38083.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/15.779165f5.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/16.ca4df33e.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/17.16828c35.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/18.87f2c094.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/19.499058bc.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/20.b6f2aa0f.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/21.23804236.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/22.ac5704f6.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/23.a47a0d33.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/24.baca3822.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/25.0ae4bbcd.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/26.341ef546.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/27.dc046beb.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/28.e7868730.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/29.d688caa7.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/3.18fa004f.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/30.40da3c45.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/31.66330c22.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/32.9fb87378.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/33.5d04c241.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/34.3fda2b29.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/35.bafd86c1.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/36.f2e3a99e.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/37.c45b9fe3.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/38.209da85f.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/39.044c39a2.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/4.f360705a.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/40.ce999257.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/41.bb229357.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/42.7ff994e5.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/43.148fcb76.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/44.bec5f867.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/45.5f149ba5.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/47.a7aa1bea.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/48.38157b22.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/49.d163de48.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/5.80838c68.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/50.d9ef6801.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/6.a35f48c1.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/7.dcfc7606.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/8.0cd994c1.js"><link rel="prefetch" href="/knowledgeNotes/assets/js/9.0b838162.js">
    <link rel="stylesheet" href="/knowledgeNotes/assets/css/0.styles.64ebfe11.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/knowledgeNotes/" class="home-link router-link-active"><!----> <span class="site-name">前端知识体系</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程规范</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>网络协议</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架与库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端安全</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledgeNotes/mianshi/1.js.html" class="sidebar-link">JavaScript</a></li><li><a href="/knowledgeNotes/mianshi/2.es6.html" class="sidebar-link">ES6</a></li><li><a href="/knowledgeNotes/mianshi/3.编码题.html" class="sidebar-link">编码题</a></li><li><a href="/knowledgeNotes/mianshi/4.html、css.html" class="sidebar-link">HTML、CSS</a></li><li><a href="/knowledgeNotes/mianshi/5.网络协议.html" class="sidebar-link">网络协议</a></li><li><a href="/knowledgeNotes/mianshi/6.浏览器.html" class="sidebar-link">浏览器</a></li><li><a href="/knowledgeNotes/mianshi/7.框架.html" class="active sidebar-link">框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#vue2-和-react的区别" class="sidebar-link">vue2 和 react的区别</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#vue面试题" class="sidebar-link">vue面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#mvvm原理" class="sidebar-link">mvvm原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#react" class="sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#react的生命周期" class="sidebar-link">React的生命周期</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#react的请求应该放在哪个生命周期中" class="sidebar-link">React的请求应该放在哪个生命周期中?</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#react-中的-key" class="sidebar-link">React 中的 key</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#setstate到底是异步还是同步" class="sidebar-link">setState到底是异步还是同步?</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#组件通信" class="sidebar-link">组件通信</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#你是如何理解react-fiber的" class="sidebar-link">你是如何理解React-fiber的?</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#react的hooks" class="sidebar-link">React的hooks</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#是否了解-diff算法" class="sidebar-link">是否了解 diff算法</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#虚拟-dom" class="sidebar-link">虚拟 dom</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#react-合成事件机制" class="sidebar-link">React 合成事件机制</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#react-性能优化方案" class="sidebar-link">React 性能优化方案</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#高阶组件" class="sidebar-link">高阶组件</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#react-purecomponent的作用" class="sidebar-link">React.PureComponent的作用</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#context" class="sidebar-link">Context</a></li><li class="sidebar-sub-header"><a href="/knowledgeNotes/mianshi/7.框架.html#react-router的路由有几种模式" class="sidebar-link">React-Router的路由有几种模式？</a></li></ul></li></ul></li><li><a href="/knowledgeNotes/mianshi/9.性能优化.html" class="sidebar-link">前端性能优化</a></li><li><a href="/knowledgeNotes/mianshi/10.前端安全.html" class="sidebar-link">前端安全</a></li><li><a href="/knowledgeNotes/mianshi/12.前端工程.html" class="sidebar-link">webpack</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="框架"><a href="#框架" class="header-anchor">#</a> 框架</h1> <h2 id="vue2-和-react的区别"><a href="#vue2-和-react的区别" class="header-anchor">#</a> vue2 和 react的区别</h2> <ol><li>Vue 使用的是 web 开发者更熟悉的模板与特性，比如单文件组件是以HTML模板+CSS+JS的组合形式以及约定好的命令，以及封装了许多常用的功能，比如路由守卫，keep-alive，这样使得新入门的前端工程师更加容易接受Vue。</li></ol> <p>而React的特色在于函数式编程的理念与丰富的技术选型。</p> <p>相对来说，React更适合入门多年的前端工程师，因为在写法上没有像Vue那样的约定式的命令，如果需要什么功能，就自己去实现。
对于入门多年的前端来说，React可能更加得心应手。</p> <ol start="2"><li>实现上，vue和react最大的区别在于数据的响应上。vue提供了响应式的数据，当数据改动时，数据本身会把这个改动推送出去，告知渲染系统自动更新，而react需要通过setState，给系统一个明确的信号说明现在要开始重新渲染了，这个系统才开始渲染，两者没有绝对优劣势。</li></ol> <h2 id="vue面试题"><a href="#vue面试题" class="header-anchor">#</a> vue面试题</h2> <p>生命周期、nextick、v-if 和 v-for、组件通信</p> <h3 id="mvvm原理"><a href="#mvvm原理" class="header-anchor">#</a> mvvm原理</h3> <ul><li>通过Object.defineProperty的get和set进行数据劫持</li> <li>通过正则找到模板中的<code>{{}}</code>，替换<code>{{}}</code>中间的值，对数据进行编译</li> <li>通过发布订阅模式实现数据与视图同步</li> <li>双向绑定：（1）取到模板中的v-model值，（2）通过发布订阅模式监听数据变化并同步视图，将数据添加输入框中，（3）接着通过addEventListen监听输入框的变化，值设置成输入的值.</li></ul> <h2 id="react"><a href="#react" class="header-anchor">#</a> React</h2> <p>react面试题</p> <h3 id="react的生命周期"><a href="#react的生命周期" class="header-anchor">#</a> React的生命周期</h3> <p>挂载：</p> <p>constructor: 初始化state、为处理事件绑定this
static getderivedStateFromProps：如果state的值都取决于Props，可以用这个钩子
render: 渲染函数，返回需要渲染的东西，可以是DOM、React组件等等
Didmount: 挂载后立即执行，可以在此钩子发起网络请求、添加订阅</p> <p>更新：</p> <p>static getderivedStateFromProps
shouldComponentUpdate: 有两个参数nextProps和NextStates，表示新的属性和变化之后的props和state，返回一个布尔值默认为true，true表示重新渲染，false表示不渲染，可以通过此钩子做性能优化。
render
beforUpdate: 两个参数prevProps，prevState，这个钩子有一个返回值，会传给didUpdate的第三个参数，必须搭配Didupdate使用。
如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程放在此钩子， componentDidUpdate 中统一触发回调或更新状态。</p> <p>DidUpdate: 三个参数prevProps，prevState，snapshot，表示之前的Props、state、以及beforUpdate传递过来的值，更新后立即执行，可以用于对比更新前后的state来判断是否进行后面的操作</p> <p>卸载：</p> <p>willUnmount: 卸载前执行，必须在此钩子中清除定时器、取消网络请求、或者清除在Didmount中添加的订阅。</p> <h3 id="react的请求应该放在哪个生命周期中"><a href="#react的请求应该放在哪个生命周期中" class="header-anchor">#</a> React的请求应该放在哪个生命周期中?</h3> <p>放在DidMount或者有条件判断的DidUpdate中，
放在WillMount会有可能导致多次调用的问题。</p> <h3 id="react-中的-key"><a href="#react-中的-key" class="header-anchor">#</a> React 中的 key</h3> <ul><li><p>key 是 react 在渲染一系列相同类型的兄弟元素时，给每个元素指定一个唯一的值，来帮助 React 识别哪些元素改变了。</p></li> <li><p>避免在某些场景下，元素的错误渲染，比如添加和删除。</p></li> <li><p>提升 React 的渲染性能：在使用 diff 算法对比 react 更新前后两棵树的比较时，使得树的转换效率得以提高，组件实例基于它们的 key 来决定是否更新以及复用。</p></li></ul> <h3 id="setstate到底是异步还是同步"><a href="#setstate到底是异步还是同步" class="header-anchor">#</a> setState到底是异步还是同步?</h3> <p>先给出答案: 有时表现出异步,有时表现出同步</p> <ol><li><p>setState只在<strong>合成事件</strong>和<strong>钩子函数</strong>中为异步的，在<strong>原生事件</strong>和<strong>setTimeout</strong>中是同步的。</p></li> <li><p>setState 中的异步不是说，内部由异步代码实现，而是合成事件和钩子函数的调用都在更新之前。</p></li></ol> <h3 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h3> <ul><li><p>父组件向子组件传递：props</p></li> <li><p>子组件向父组件传递：在父组件中定义一个回调函数，在通过props将该函数传递给子组件，子组件就可以通过调用该函数将信息传递给父组件。</p></li> <li><p>同级组件之间的信息传递：通过状态提升</p></li> <li><p>跨层级传递信息：使用状态管理库、context、可以自定义事件（发布订阅者模式）</p></li></ul> <h3 id="你是如何理解react-fiber的"><a href="#你是如何理解react-fiber的" class="header-anchor">#</a> 你是如何理解React-fiber的?</h3> <p>fiber 产生的背景</p> <ul><li>react 16.0之前渲染过程会递归比对 VirtualDOM 树，并且更新是同步的，如果要更新一个庞大的组件，那么js占据主线程时间过长，会导致页面响应速度变差，使得react在动画、手势等应用中表现的较差。</li></ul> <p>为了解决这一问题出现了React 通过Fiber 架构，让更新渲染过程变的可切断，适当的让出CPU执行权，这样做可以让浏览器及时响应用户的操作</p> <p>Fiber树：react在render函数调用时，生成了一个Elemnt树，可以称之为虚拟DOM树，由于要记录上下文信息，加入到了Firbe中，每个Elemnt 都有对于的Firbe Node。</p> <p>将fiber Node链接起来就成了Fiber Tree。</p> <p>Fiber Tree的特点是链表结构循环遍历然后配合requestIdleCallback 实现任务拆分、终端恢复。</p> <h3 id="react的hooks"><a href="#react的hooks" class="header-anchor">#</a> React的hooks</h3> <ol><li><p>useState
相当于 class组件中的 this.setState()</p></li> <li><p>useEffect</p></li></ol> <p>Effect Hook 执行副作用操作, 还可以进行清除订阅</p> <ol start="3"><li>useReducer</li></ol> <p>useState的替换方案，例如用于处理 state 逻辑较复杂且包含多个子值、下一个 state 依赖于之前的 state等</p> <ol start="4"><li>useContext</li></ol> <p>useContext(MyContext)相等于 class组件中的 &lt;MyContext.Consumer&gt;，用于读取context的值和订阅context的变化</p> <ol start="5"><li>useMemo</li></ol> <p>用于优化高开销的计算优化</p> <ol start="6"><li>useRef</li></ol> <p>配合ref使用，用于获取元素DOM属性</p> <h3 id="是否了解-diff算法"><a href="#是否了解-diff算法" class="header-anchor">#</a> 是否了解 diff算法</h3> <p>diff算法</p> <p>当对比两个元素的时候，React首先对比两棵树的根元素。不同情况有不用的形态。</p> <p>第一种，当两个根元素的类型不同的时候，react会卸载原有的数并建立新的树。</p> <p>第二种，当两个根元素的类型相同时，react仅对比及更新属性。</p> <p>第三种，当对比两个组件元素的时候，组件实例会保持不变，只会更新Props属性来保证与最新的元素保持一致。</p> <p>第四种，当元素下面有多个类似的元素时，比如li。那么在添加时，如果向头部插入会比在尾部插入开销来的大，引入在头部插入
React意识不到元素的变化，只会重新构建每一个元素。</p> <p>为了解决这个问题React引入了key属性，假如给每一个li加入key之后，再向头部加入一个新的li，那么React可以根据key能够知道原来的元素可以复用
只是移动了而已。key的值可以是数组下标，这在不重新排序的情况下是适合的，否则就会使diff变慢。</p> <h3 id="虚拟-dom"><a href="#虚拟-dom" class="header-anchor">#</a> 虚拟 dom</h3> <ol><li>定义</li></ol> <p>虚拟DOM是一种 DOM节点 的抽象数据结构。</p> <ol start="2"><li>作用</li></ol> <p>比起使用虚拟DOM后更新真实DOM，直接浏览器操作DOM的代表更加昂贵，频繁操作DOM会产生性能问题。</p> <p>虚拟DOM是根据每一次响应式数据引起的变化，去对比前后的虚拟DOM，匹配出需要更新的节点，再去让真实的DOM更新。</p> <ol start="3"><li>实现原理</li></ol> <ul><li><p>用js对象模拟真实DOM，对真实DOM进行抽象。</p></li> <li><p>diff算法 —— 比较两颗虚拟DOM数的差异</p></li> <li><p>patch算法 —— 将两颗虚拟DOM对比的结果应用到真正的树。</p></li></ul> <h3 id="react-合成事件机制"><a href="#react-合成事件机制" class="header-anchor">#</a> React 合成事件机制</h3> <ol><li>含义</li></ol> <p>React 中有自己的事件系统模式，通常被称为 React 合成事件。</p> <ol start="2"><li>作用</li></ol> <ul><li><p>为了抹平事件在不同平台体现出来的差异性，这使得 React 开发者不需要自己再去关注浏览器事件兼容性问题；</p></li> <li><p>为了统一管理事件，提高性能。</p></li></ul> <ol start="3"><li>原理</li></ol> <p>不会把事件处理机制直接绑在真实节点上，而是把事件绑定在document，使用一个统一的事件监听器。</p> <p>当事件挂在或者卸载时，只是在这个统一的事件监听器上插入或删除；</p> <p>当事件发生时，首先被这个统一的事件监听器处理，然后通过事件映射表找到真实的处理函数来执行。</p> <p>这样做简化了事件处理和回收机制。</p> <h3 id="react-性能优化方案"><a href="#react-性能优化方案" class="header-anchor">#</a> React 性能优化方案</h3> <ul><li><p>减少不必要渲染，如用 shouldComponentUpdate、PureComponent、React.memo 实现</p></li> <li><p>数据缓存</p> <ul><li>useMemo 缓存参数、useCallback 缓存函数</li> <li>函数、对象尽量不要使用内联形式(如 context 的 value object、refs function)</li> <li>Route 中的内联函数渲染时候使用 render 或者 children，不要使用 component， 当你用 component 的时候，Router 会用指定的组件和 React.createElement 创建一个新 的[React elment]。这意味着当你提供的是一个内联函数的时候，每次创建 render 都会创建一个新的组件。这会导致不再更新已经现有组件，⽽是直接卸载然后再去挂载⼀个新的 组件。因此，当⽤到内联函数的内联渲染时，请使⽤render 或者 children。</li></ul></li> <li><p>懒加载，对于长页表分页加载</p></li> <li><p>减少 http 请求</p></li></ul> <h3 id="高阶组件"><a href="#高阶组件" class="header-anchor">#</a> 高阶组件</h3> <ol><li>含义</li></ol> <p>高阶组件是参数为组件，返回值为新组件的函数</p> <ol start="2"><li>作用</li></ol> <p>我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。这正是高阶组件擅长的地方。</p> <ol start="3"><li>注意事项</li></ol> <ul><li><p>不要改变原始组件，使用组合的方式。</p></li> <li><p>在HOC中将不相关的props, 传入新的组件</p></li> <li><p>HOC，不仅只有一个参数：组件，也可以传入别的参数</p></li> <li><p>HOC包装时，显示组件名称，便于调试。</p></li> <li><p>不要在render中使用HOC</p></li> <li><p>HOC包装时，务必复制静态方法</p></li> <li><p>Refs 不会被传递，这个问题的解决方案是通过使用 React.forwardRef</p></li></ul> <h3 id="react-purecomponent的作用"><a href="#react-purecomponent的作用" class="header-anchor">#</a> React.PureComponent的作用</h3> <p>当组件的props或state改变时，React.PureComponent能够自动执行shouldComponentUpdate，去进行浅比较，浅比较只能对比基本类型的数据
无法对比引用类型的数据。所以React.PureComponent比较适合用于纯组件或者Props或state为基本类型的组件。</p> <h3 id="context"><a href="#context" class="header-anchor">#</a> Context</h3> <ol><li><p>何时使用Context: 当组件树需要一个共享的“全局”数据时使用，使用场景例如：全局主题、全局语言</p></li> <li><p>API</p></li></ol> <ul><li>React.createContext: 创建一个context</li> <li>Class.contextType: 挂载在class上的属性，可以用创建的React.createContext()赋值，然后在组件中通过this.context来获取最近的context的值</li> <li>Context.Consumer： 在Context.Consumer中放一个函数组件，在将context值传递给函数组件</li></ul> <h3 id="react-router的路由有几种模式"><a href="#react-router的路由有几种模式" class="header-anchor">#</a> React-Router的路由有几种模式？</h3> <p>HashRouter: 带#
BrowserRouter:  不带#，美观，上线后需要后端处理.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/knowledgeNotes/mianshi/6.浏览器.html" class="prev">
        浏览器
      </a></span> <span class="next"><a href="/knowledgeNotes/mianshi/9.性能优化.html">
        前端性能优化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/knowledgeNotes/assets/js/app.62fdb92b.js" defer></script><script src="/knowledgeNotes/assets/js/2.53f1d7f8.js" defer></script><script src="/knowledgeNotes/assets/js/46.ccfce139.js" defer></script>
  </body>
</html>
