# 作用域和闭包

## 作用域
作用域是存储和维护变量的区域，并且规定了变量的访问权限。

javaScript是使用词法作用域

## 词法作用域

词法作用域是指书写代码时就决定了代码块的作用域

动态作用域是指运行代码时才决定代码块的作用域

举个例理解一下：
```js
var a = 1
function scope() {
  var a = 2;
  console.log(a)
}
scope() // 词法作用域会输出：2 动态作用域会输出：1
```
scope函数在书写时，作用域是scope，所以输出作用域中的变量a为2

## 执行上下文

1. js执行函数前会先进行准备一个环境，用专业术语就叫执行上下文，这个过程要用到栈，将函数的上下文放入上下文栈中
2. 在执行一个脚本的时候，js会将全局上下文压入栈中

```js
let a = 20;
const b = 30;
var c;

function multiply(e, f) {
 var g = 20;
 let h = 40
 return e * f * g * h;
}

c = multiply(20, 30);
```
执行上下文看起来像这样：


```js
全局执行上下文 = {
  this绑定: 全局对象,
  词法环境: {
    环境记录器:{ 
      类型: "对象"
      // 绑定标识符
      a: 未初始化,
      b: 未初始化,
      multiply: 函数,
    },
    外部环境的引用: null
  },
  变量环境: {
    环境记录器: {
      类型: "对象",
      // 绑定标识符
      c: undefined,
    }
  },
}

函数执行上下文 = {
  this绑定: 全局对象,
  词法环境: {
    环境记录器: {
      类型: "声明式",
      // 绑定标识符
      h: undefined,
      Arguments: {0: 20, 1: 30, length: 2},
    },
    外部环境的引用: <全局或外部函数环境>,
  },
  变量环境: {
    环境记录器: {
      类型: "声明式",
      g: undefined
    }
  },
}
```

## 执行上下文栈
执行栈看起来像这样：
```js
执行栈 = [
  multiply上下文,
  全局上下文
]
```

## 闭包

 ### 什么是闭包

当一个函数可以记住并访问所在的词法作用域时，这个词法作用域会被该函数所引用，这个引用就是闭包，即使函数是在当前词法作用域之外执行。

```js
function foo () {
  var a = 1;
  function baz() {
    console.log(a)
  }
  return baz;
}
var bar = foo()
bar();
```

正常来说，在作用域外部执行的话，无法访问到作用域内的变量的，但是这里因为存在闭包的原因， bar能输出1。

正常情况下，foo函数在执行完之后，因为浏览器的垃圾回收机制，会摧毁foo同时作用域也会摧毁。

然而bar却还是能输出1，这完全归功于闭包，才使得foo的作用域得以保存。

 ### 闭包产生的原因？

产生闭包的原因和作用域有着莫大的关联。

当访问一个变量的时候，解释器就会在当前作用域查找，如果找不到会向上一级查找，直到全局作用域。

在这样的一个过程中一旦函数去访问外部作用域就产生了闭包。

 ### 闭包有哪些表现形式?

1. 在一个函数中，内部的函数去访问其作用域的变量。
2. 作为函数参数传递
3. 定时器、事件监听、ajax请求、任何异步中、自执行函数，只要使用了回调函数，实际上就是在使用闭包

 ### 怎么清除闭包

  在不需要的时候，将其设置为null

