# 代理模式
代理模式是为一个对象提供**一个代用品**或占位符，以便控制对它的访问。

代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个**替身**对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求**转交**给**本体**对象
## 虚拟代理
虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建
### 虚拟代理实现图片预加载

```js
// 本体
var myImage = (function() {
    var img = document.createElement('img');
    return {
        setSrc: function(src) {
            document.body.appendChild(img);
            img.src = src;
        }
    }
})()

var proxyDiv = (function(){
    var img = new Image
    img.onload = function() {
        document.body.innerHTML = ''
        myImage.setSrc(this.src)
    }
    return {
        setSrc: function(src) {
            document.body.innerHTML = 'loading...'
            img.src = src;
        }
    }
})()

proxyDiv.setSrc('https://volunteer.cdn-go.cn/404/latest/img/freelunch1600.jpg')
```

### 代理的意义

为了说明代理的意义，下面我们引入一个面向对象设计的原则——**单一职责原则**。

单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该**仅有一个引起它变化的原因**。

如果我们只是从网络上获取一些**体积很小的图片**，或者5年后的网速快到根本**不再需要预加载**，我们可能希望把**预加载图片**的这段代码从MyImage对象里**删掉**。这时候就**不得不改动MyImage对象**了。

实际上，只是给**img节点设置src**，**预加载图片**只是一个**锦上添花**的功能，把这个操作**放在另一个对象**里面，就**可以不要改动**MyImage对象。

于是**代理的作用**在这里就**体现**出来了，**代理负责预加载图片**，预加载的**操作完成**之后，把请求**重新交给本体**MyImage。

### 代理和本体接口的一致性

如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请求本体。

其中关键是代理对象和本体都对外提供了setSrc方法，在客户看来，代理对象和本体是一致的，代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别。


### 虚拟代理合并HTTP请求
这些checkbox绑定点击事件，并且在点击的同时往另一台服务器同步文件：

```html
<input type="checkbox" id="1" />1
<input type="checkbox" id="2" />2
<input type="checkbox" id="3" />3
<input type="checkbox" id="4" />4
<input type="checkbox" id="5" />5
<input type="checkbox" id="6" />6
<input type="checkbox" id="7" />7
<input type="checkbox" id="8" />8
<input type="checkbox" id="9" />9
```
```js
var synchronousFile = function(id) {
    console.log('开始同步文件，id为:' + id);
}

var checkbox = document.getElementsByTagName('input')

for(var i = 0, c; c = checkbox[i++];) {
    c.onclick = function() {
        if (this.checked = true) {
            synchronousFile(this.id)
        }
    }
}
```
当我们选中3个checkbox的时候，依次往服务器发送了3次同步文件的请求。当我们选中3个checkbox的时候，依次往服务器发送了3次同步文件的请求。

解决方案：可以通过一个代理函数proxySynchronousFile来收集一段时间之内的请求，最后一次性发送给服务器

```js
var synchronousFile = function(id) {
    console.log('开始同步文件，id为:' + id);
}

var proxy = (function() {
    var cache = [];
    var timer;
    return function(id) {
        cache.push(id);
        if (!timer) {
            timer = setTimeout(function() {
                synchronousFile(cache.join(','))
                clearTimeout(timer)
                timer = null;
                cache.length = 0;
            }, 2000)
        }
    }
})()

var checkbox = document.getElementsByTagName('input')

for(var i = 0, c; c = checkbox[i++];) {
    c.onclick = function() {
        if (this.checked = true) {
            proxy(this.id)
        }
    }
}
```

### 虚拟代理在惰性加载中的应用

我们并不想一开始就加载大的JS文件

未加载真正的miniConsole.js

```js
var cache = [];

var miniConsole = {
    log: function() {
        var args = arguments;
        cache.push(function() {
            return miniConsole.log.apply(miniConsole, args);
        })
    }
}

miniConsole.log(1)
```

当用户按下F2时，开始真正加载miniConsole.js,代码如下：

```js

var miniConsole = (function(){
    var cache = [];
    var handler = function(e) {
        if(e.keyCode === 113) {
            var script = document.createElement('script');
            script.onload = function() {
                for(var i = 0, fn; fn = cache[i++];) {
                    fn();
                }
            };
            script.src = '3.miniConsole.js';
            document.getElementsByTagName('head')[0].appendChild(script);
            document.body.removeEventListener('keydown', handler, false)
        };
    }
    document.body.addEventListener('keydown', handler, false)
    return {
        log: function() {
            var args = arguments;
            cache.push(function() {
                return miniConsole.log.apply(miniConsole, args);
            })
        }
    }
})()

miniConsole.log(1)
```

## 缓存代理

缓存代理可以为一些开销大的运算结果提供暂时存储，在下次运算时，如果传进来的参数跟之前一致，则可以直接返回前面存储的运算结果。

### 缓存代理的例子————计算乘积

```js
// 计算乘积

function chéngFǎ() {
    console.log('开始计算乘积');
    var a = 1;
    for(var i = 0; i < arguments.length; i++) {
        a = a * arguments[i];
    }
    return a;
}

// 缓存代理

var proxy = (function() {
    var cache = {};
    return function() {
        var args = Array.prototype.join.call(arguments, ',')
        if (args in cache) {
            return cache[args]
        }
        return cache[args] = chéngFǎ.apply(this, arguments)
    }
})()

alert(proxy(2, 3, 4))
alert(proxy(2, 3, 4))
```

### 缓存代理用于ajax异步请求数据

**分页的需求**，同一页的数据**拉取一次**，**缓存起来**，下次请求同一页的时候，直接**使用缓存的数据**。

实现方式跟计算乘积的例子差不多，唯一不同的是，请求数据是个异步的操作，要通过**回调**的方式。

### 用高阶函数动态创建代理

通过高阶函数，创建缓存代理。计算方法被当作参数传入用于创建代理的工厂。
这样，可以为加减乘除等创建缓存代理，代码如下：

```js
// 计算乘积

var chéngFǎ = function() {
    console.log('开始计算乘法');
    var a = 1;
    for(var i = 0; i < arguments.length; i++) {
        a = a * arguments[i];
    }
    return a;
}

var jiāFǎ = function() {
    console.log('开始计算加法');
    var a = 0;
    for(var i = 0; i < arguments.length; i++) {
        a += arguments[i];
    }
    return a 
}

// 缓存代理

var dàiLǐ = function(fn) {
    var cache = {};
    return function() {
        var args = Array.prototype.join.call(arguments, ',')
        if (args in cache) {
            return cache[args]
        }
        return cache[args] = fn.apply(this, arguments)
    }
}

var dàiLǐChéngFǎ = dàiLǐ(chéngFǎ);
var dàiLǐJiāFǎ = dàiLǐ(jiāFǎ)

console.log(dàiLǐChéngFǎ(2, 3, 4))
console.log(dàiLǐChéngFǎ(2, 3, 4))
console.log(dàiLǐJiāFǎ(2, 3, 4))
console.log(dàiLǐJiāFǎ(2, 3, 4))
```

## 其他代理模式

+ 防火墙代理：控制网络资源的访问，保护主体不让“坏人”接近。
+ 远程代理： 为一个对象在不同的地址空间提供局部代表。
+ 保护代理：用于对象应用有不同访问权限的情况。
+ 智能引用代理： 取代了简单的指针，它在访问对象时执行一些附件操作，比如计算一个对象被引用的次数。
+ 写时复制代理： 通过用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，
当对象被真正修改时，才对它进行复制操作。是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景

## 小结

我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式。

当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。