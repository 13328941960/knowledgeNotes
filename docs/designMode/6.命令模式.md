# 命令模式

## 命令模式的用途

命令模式最常见的场景是：有时候需要向一些对象发送请求，但不知道请求的接收者是谁，也不知道被请求的操作是什么。于是想要通过一种松耦合的方式来设计程序。
使得请求发送者和请求接收者能够消除彼此的耦合关系。

拿订餐来说，客人需要向厨师发送请求，但是完全不知道厨师的名字和联系方式，也不知道厨师的炒菜方式和步骤。这个对象可以在程序中被四处传递，就像订单对象可以从服务员手中传递给厨师。这样客人无需知道厨师的任何信息。从而解开了请求者和接收者之间的耦合关系。

另外，相对于过程化的请求调用，command对象拥有更长的生命周期。对象的生命周期跟初始无关，因为这个请求已经被封装在了command对象中。
我们可以在程序运行的任意时刻去调用这个对象。就像客人可以在一小时后让厨师开始炒菜。相当于程序在1小时之后开始执行comand对象的方法。

## 命令模式————菜单程序

```js
var button1 = document.getElementById('button1');
var button2 = document.getElementById('button2');
var button3 = document.getElementById('button3');

// 负责往按钮上面安装命令
var setCommand = function(button, command) {
    button.onclick = function() {
        command.execute();
    }
}

var MenuBar = {
    refresh: function() {
        console.log('刷新菜单目录')
    },
    execute: function() {
        this.refresh()
    }
}

var addSubMenu = {
    add: function() {
        console.log('增加子菜单')
    },
    execute: function() {
        this.add()
    }
}

var delSubMenu = {
    del: function() {
        console.log('删除子菜单')
    },
    execute: function() {
        this.del()
    }
}

setCommand(button1, MenuBar)
setCommand(button2, addSubMenu)
setCommand(button3, delSubMenu)
```

## JavaScript中的命令模式

闭包实现的命令模式

```js
var setCommand = function(button, fn) {
    button.onclick = function() {
        fn();
    }
}

var MenuBar = {
    refresh: function() {
        console.log('刷新菜单目录')
    },
}

var RefreshMenuBarCommand = function(receiver){
    return function {
        receiver.refresh()
    }
}

var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);
setCommand(button1, refreshMenuBarCommand)
```

如果想要更好的表示命令模式，还要进行撤销操作，那么最好还是要用到execute函数。

```js
var RefreshMenuBarCommand = function(receiver){
    return function {
        reveiver.refresh();
    }
}

var setCommand = function(button, command) {
    button.onclick = function() {
        command.execute()
    }
}

var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);
setCommand(button1, refreshMenuBarCommand) 
```

## 撤销命令

```html
<div style="position: absolute; background: blue;" id="div">我是div</div>
<input type="text" id="pos">
<button id="moveBtn">开始移动</button>
<button id="cancelBtn">撤销</button>
```
```js
var tween = {
    zhiXian: function(haoShi, startPos, endPos, duration) {
        return endPos * haoShi / duration + startPos
    },
    jianRu: function(haoShi, startPos, endPos, duration) {
        return endPos * (haoShi /= duration) + startPos;
    },
    qiangJianRu: function(haoShi, startPos, endPos, duration) {
        return endPos * (haoShi /= duration) * Math.pow(haoShi, 4)  + startPos;
    },
    qiangJianChu: function(haoShi, startPos, endPos, duration) {
        return endPos * ( (haoShi = haoShi / duration - 1) * Math.pow(haoShi, 4) + 1 ) + startPos
    },
    sineJianRu: function(haoShi, startPos, endPos, duration) {
        return endPos * (haoShi /= duration) * Math.pow(haoShi, 2) + startPos
    },
    sineJianChu: function(haoShi, startPos, endPos, duration) {
        return endPos * ( (haoShi = haoShi / duration - 1) * Math.pow(haoShi, 2) + 1 ) + startPos
    },
}


var Animate = function(dom) {
    this.dom = dom;
    this.startTime = 0;
    this.startPos = 0;
    this.endPos = 0;
    this.domNeedChangedCssPropertyName = null;
    this.huanDongSuanfa = null;
    this.duration = null;
}

Animate.prototype.start = function(domNeedChangedCssPropertyName, endPos, duration, huanDongSuanfa) {
    this.startTime = +new Date();
    this.startPos = this.dom.getBoundingClientRect()[domNeedChangedCssPropertyName]
    this.domNeedChangedCssPropertyName = domNeedChangedCssPropertyName;
    this.endPos = endPos;
    this.duration = duration;
    this.huanDongSuanfa = tween[huanDongSuanfa]

    var self = this;
    var timeId = setInterval(function() {
        if (self.step() === false) {
            // 如果动画已结束，清除定时器
            clearInterval(timeId)
        }
    }, 19)
}

Animate.prototype.step = function() {
    var currentTime = +new Date();
    // 说明动画已经结束，修正小球的位置
    if (currentTime > this.startTime + this.duration) {
        this.update(this.endPos);
        // 通知清除定时器
        return false
    }

    var pos = this.huanDongSuanfa(
        currentTime - this.startTime,
        this.startPos,
        this.endPos - this.startPos,
        this.duration
    );

    this.update(pos)
}

Animate.prototype.update = function(pos) {
    this.dom.style[this.domNeedChangedCssPropertyName] = pos + 'px';
}

var div = document.getElementById('div');
var pos = document.getElementById('pos');
var moveBtn = document.getElementById('moveBtn');
var cancelBtn = document.getElementById('cancelBtn');

var MoveCommand = function(receiver, pos) {
    this.receiver = receiver;
    this.pos = pos;
    this.oldPos = null;
}

MoveCommand.prototype.execute = function() {
    this.receiver.start('left', this.pos, 1000, 'qiangJianChu');
    this.oldPos = this.receiver.dom.getBoundingClientRect()[this.receiver.domNeedChangedCssPropertyName];
    console.log(this.oldPos, 'this.oldPos')
    // 记录小球开始移动前的位置
}

MoveCommand.prototype.undo = function() {
    console.log(this.oldPos, 'this.oldPos')
    this.receiver.start('left', this.oldPos, 1000, 'qiangJianChu');
}

var moveCommand;

moveBtn.onclick = function() {
    var animate = new Animate(div);
    moveCommand = new MoveCommand(animate, pos.value);
    moveCommand.execute();
}

cancelBtn.onclick = function() {
    moveCommand.undo(); // 撤销命令
}

```

