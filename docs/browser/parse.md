# 资源解析

通过网络请求获取到资源后，如果该资源响应头中的 `Content-type` 是 `text/html`，
那么接下来就要进入`解析`和`渲染`的过程。

本节主要讲解资源解析的过程，分为三部：

1. 构建DOM树
2. 样式计算
3. 生成布局树

## 构建DOM树

由于浏览器无法识别`HTML`代码，所以需要通过一系列的字节流转换为一种有意义并且方便操作的数据结构。
这种数据结构就是`DOM树`。DOM树的本质就是以document为根节点的多叉树。

那么通过什么样的转换呢？

### HTML文法本质

首先，先说一下。`HTML`的文法是非上下文无关文法的。

什么是上下文无关文法？

在计算机科学的编译原理学科中，有非常明确的定义:

```
若一个形式文法G = (N, Σ, P, S) 的产生式规则都取如下的形式：V->w，则叫上下文无关语法。其中 V∈N ，w∈(N∪Σ)* 。
```

1. N 是非终结符(顾名思义，就是说最后一个符号不是它, 下面同理)集合。
2. Σ 是终结符集合。
3. P 是开始符，它必须属于 N ，也就是非终结符。
4. S 就是不同的产生式的集合。如 S -> aSb 等等。

关于`HTML`为什么是非上下文无关文法。举个例子：

比如解析器扫描到`form`标签，**上下文无法文法**的处理方式是：直接创建DOM对象。
而实际场景并不是这样，解析器会查看`form`的上下文，如果`form`这个标签外层还有一个`form`标签会忽略这个标签，否则才创建DOM对象。

## 解析算法

HTML的解析算法分别两步：

1. 标记化
2. 建树

这两个过程可以比作`词法分析`和`语法分析`。

### 标记化算法

这个算法输入是`HTML`文本，输出`HTML`标记，也称作**标记生成器**。其中运用**有限状态机**即在当前状态下，接收一个或多个字符，就会更新下一个状态。

举个简单的例子来看下标记生成的过程：

````
<html>
  <body>
    yeah, html
  </body>
</html>
````
```

通过一个简单的例子来演示一下标记化的过程。

遇到<, 状态为标记打开。

接收[a-z]的字符，会进入标记名称状态。

这个状态一直保持，直到遇到>，表示标记名称记录完成，这时候变为数据状态。

接下来遇到body标签做同样的处理。

这个时候html和body的标记都记录好了。

现在来到<body>中的>，进入数据状态，之后保持这样状态接收后面的字符yeah, html

接着接收 </body> 中的<，回到标记打开, 接收下一个/后，这时候会创建一个end tag的token。

随后进入**标记名称状态**, 遇到>回到**数据状态**。

接着以同样的样式处理 </html>
```

### 建树算法

DOM 树是一个以document为根节点的多叉树，因此解析器首先会创建一个document对象。
标记生成器会把每个标记的信息发送给建树器。
建树器接收到相应的标记时，会创建对应的 DOM 对象。
创建这个DOM对象后会做两件事情:

1. 将DOM对象加入DOM树中
2. 将对应的标签压入存储开放元素的栈中

还是拿下面这个例子说:

```
<html>
  <body>
    yeah, html
  </body>
</html>
```

首先，状态为初始化状态。

接收到标记生成器传来的html标签，这时候状态变为before html状态。同时创建一个HTMLHtmlElement的 DOM 元素, 将其加到document根对象上，并进行压栈操作。

接着状态自动变为before head, 此时从标记生成器那边传来body，表示并没有head, 这时候建树器会自动创建一个HTMLHeadElement并将其加入到DOM树中。

现在进入到in head状态, 然后直接跳到after head。

现在标记生成器传来了body标记，创建HTMLBodyElement, 插入到DOM树中，同时压入开放标记栈。

接着状态变为in body，然后来接收后面一系列的字符: yeah, html。接收到第一个字符的时候，会创建一个Text节点并把字符插入其中，然后把Text节点插入到 DOM 树中body元素的下面。随着不断接收后面的字符，这些字符会附在Text节点上。


现在，标记生成器传过来一个body的结束标记，进入到after body状态。

标记生成器最后传过来一个html的结束标记, 进入到after after body的状态，表示解析过程到此结束。

### 容错机制

HTML规范有很强大的宽容策略，接下来来看下 webkit一些经典的容错案例：

1.  使用</br>而不是<br>

```js
if (t->isCloseTag(brTag) && m_document->inCompatMode()) {
  reportError(MalformedBRError);
  t->beginTag = true;
}
```
全部换为<br>的形式。

2. 表格

```
<table>
  <table>
    <tr><td>inner table</td></tr>
  </table>
  <tr><td>outer table</td></tr>
</table>
```
转成

```
<table>
    <tr><td>outer table</td></tr>
</table>
<table>
    <tr><td>inner table</td></tr>
</table>
```

3. 表单元素嵌套

这时候直接忽略里面的form。



## 样式计算

样式的计算就是css的计算。由于浏览器无法直接识别css文本样式，所以渲染引擎要先进行解析计算。

这个过程分为三步：

1. 将css样式转成结构化的对象，即styleSheets，可以通过控制台document.styleSheets来查看。这个过程称为规则化样式表。

2. 将一些浏览器不好识别样式数值标准化，比如：red => #00fff, bold => 700, em => px;

3. 计算每个具体节点的样式：前面两步已经将样式规则化以及标准化，接下来就可以计算每个节点的具体样式信息了。

    计算的规则就两种（1）继承（2）层叠

    每个子节点都会继承父节点的样式，如果没有父节点的样式，则会继承浏览器默认的样式即userAgent。这就是继承的规则。

    层叠的规则就是综合各个样式属性最后得到的结果。

    在计算后样式后，会将所有的样式值挂到document.compuedStyles上，这样JS就可以直接获取样式了。

## 生成布局树

前面已经生成`DOM树`和`DOM样式`，接下来就可以开始通过浏览器的布局系统`确定元素的位置`，也就是生成一棵`布局树`。

生成`布局树`的过程有两步：

1. 将DOM树节点添加到布局树中

2. 计算布局树节点的位置。 