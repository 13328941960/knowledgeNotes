(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{135:function(t,a,r){"use strict";r.r(a);var e=r(0),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"回流与重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流与重绘"}},[t._v("#")]),t._v(" 回流与重绘")]),t._v(" "),e("p",[t._v("回顾一下渲染过程：")]),t._v(" "),e("p",[e("img",{attrs:{src:r(95),alt:"An image"}})]),t._v(" "),e("h2",{attrs:{id:"回流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流"}},[t._v("#")]),t._v(" 回流")]),t._v(" "),e("p",[t._v("对DOM结构的修改导致几尺寸变化，会发生回流。")]),t._v(" "),e("h3",{attrs:{id:"具体的例子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#具体的例子"}},[t._v("#")]),t._v(" 具体的例子")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("DOM元素的几何属性发生变化："),e("code",[t._v("height")]),t._v("、"),e("code",[t._v("width")]),t._v("、"),e("code",[t._v("padding")]),t._v("、"),e("code",[t._v("margin")]),t._v("、"),e("code",[t._v("left")]),t._v("、"),e("code",[t._v("top")]),t._v("、"),e("code",[t._v("border")])])]),t._v(" "),e("li",[e("p",[t._v("使 DOM 节点发生增减或者移动")])]),t._v(" "),e("li",[e("p",[t._v("读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。")])]),t._v(" "),e("li",[e("p",[t._v("调用 window.getComputedStyle 方法。")])])]),t._v(" "),e("h3",{attrs:{id:"回流过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流过程"}},[t._v("#")]),t._v(" 回流过程")]),t._v(" "),e("p",[t._v("依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(96),alt:"An image"}})]),t._v(" "),e("p",[t._v("相当于将解析和合成的过程重新又走了一篇，开销是非常大的")]),t._v(" "),e("h2",{attrs:{id:"重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),e("p",[t._v("当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致"),e("strong",[t._v("重绘(repaint)")]),t._v("。")]),t._v(" "),e("p",[t._v("由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。")]),t._v(" "),e("h3",{attrs:{id:"重绘流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘流程"}},[t._v("#")]),t._v(" 重绘流程")]),t._v(" "),e("p",[e("img",{attrs:{src:r(97),alt:"An image"}})]),t._v(" "),e("p",[t._v("跳过了生成布局树和建图层树的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。")]),t._v(" "),e("p",[t._v("可以看到，重绘不一定导致回流，但回流一定发生了重绘。")]),t._v(" "),e("h2",{attrs:{id:"合成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#合成"}},[t._v("#")]),t._v(" 合成")]),t._v(" "),e("p",[t._v("例如利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速。")]),t._v(" "),e("h3",{attrs:{id:"gpu加速的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gpu加速的原因"}},[t._v("#")]),t._v(" GPU加速的原因")]),t._v(" "),e("p",[t._v("在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。")]),t._v(" "),e("h3",{attrs:{id:"好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#好处"}},[t._v("#")]),t._v(" 好处")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。")])]),t._v(" "),e("li",[e("p",[t._v("没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。")])])]),t._v(" "),e("h2",{attrs:{id:"实践意义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实践意义"}},[t._v("#")]),t._v(" 实践意义")]),t._v(" "),e("p",[t._v("知道上面的原理之后，对于开发过程有什么指导意义呢？")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("避免频繁使用 style，而是采用修改class的方式。")])]),t._v(" "),e("li",[e("p",[t._v("使用createDocumentFragment进行批量的 DOM 操作。")])]),t._v(" "),e("li",[e("p",[t._v("对于 resize、scroll 等进行防抖/节流处理。")])]),t._v(" "),e("li",[e("p",[t._v("添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于tranform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。这里有一个实际的例子，一行will-change: tranform拯救一个项目，"),e("a",{attrs:{href:"https://juejin.im/post/5da52531518825094e373372",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://juejin.im/post/5da52531518825094e373372"),e("OutboundLink")],1),t._v("。")])])])])}),[],!1,null,null,null);a.default=s.exports},95:function(t,a,r){t.exports=r.p+"assets/img/1590632436(1).2515b4a1.png"},96:function(t,a,r){t.exports=r.p+"assets/img/1590632020(1).83e3597b.png"},97:function(t,a,r){t.exports=r.p+"assets/img/1590632105(1).709855cd.png"}}]);