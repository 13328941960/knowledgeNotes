(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{129:function(t,s,a){"use strict";a.r(s);var n=a(0),v=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"数据类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),n("p",[t._v("JS标准规定了"),n("strong",[t._v("8种")]),t._v("数据类型，其中有7种简单数据类型："),n("code",[t._v("Undefind")]),t._v(" "),n("code",[t._v("Null")]),t._v(" "),n("code",[t._v("Boolean")]),t._v(" "),n("code",[t._v("Number")]),t._v(" "),n("code",[t._v("String")]),t._v(" "),n("code",[t._v("Symbol")]),t._v(" "),n("code",[t._v("BigInt")]),t._v("。\n以及1种复杂数据类型："),n("code",[t._v("Object")])]),t._v(" "),n("h2",{attrs:{id:"undefined-类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#undefined-类型"}},[t._v("#")]),t._v(" Undefined 类型")]),t._v(" "),n("p",[t._v("Undefined 类型只有一个值，即特殊的 undefined。未初始化的变量会自动被赋予undefined值，但是显示地初始化变量依然是明智的选择。")]),t._v(" "),n("h2",{attrs:{id:"null-类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#null-类型"}},[t._v("#")]),t._v(" Null 类型")]),t._v(" "),n("p",[t._v("Null 类型只有一个值，null。从逻辑角度来看，null值表示一个"),n("strong",[t._v("空对象指针")]),t._v("，而这也正是typeof操作符检测null值时返回“object”的原因。")]),t._v(" "),n("p",[t._v("如果定义的变量准备在"),n("strong",[t._v("将来用于保存对象")]),t._v("，那么最好将该变量初始化为null而不是其他值。\n这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的应用，如下面的例子")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("car "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("实际上，undefined值是派生自null值的，因此ECMA-262规定它们的相等性测试要返回true;")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),n("h2",{attrs:{id:"boolean-类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#boolean-类型"}},[t._v("#")]),t._v(" Boolean 类型")]),t._v(" "),n("p",[t._v("Boolean 类型时JS中使用最多的一种类型，该类型只有两个字面量：true和false。")]),t._v(" "),n("h2",{attrs:{id:"string类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#string类型"}},[t._v("#")]),t._v(" String类型")]),t._v(" "),n("p",[n("strong",[t._v("1. 字符串")])]),t._v(" "),n("p",[t._v("String 数据类型包含一些特殊的字符字面量，也叫转移序列，用于表达非打印字符，或者具有其他用途的字符")]),t._v(" "),n("p",[n("strong",[t._v("2. 字符串的特点")])]),t._v(" "),n("p",[t._v("JS中的字符串是"),n("strong",[t._v("不可变的")]),t._v("，也就说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要摧毁原来的字符串，\n然后再用另一个包含新值的字符串填充该变量，例如：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v("  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" lang "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'java'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  lang "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" lang "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Script"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("h2",{attrs:{id:"number类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#number类型"}},[t._v("#")]),t._v(" Number类型")]),t._v(" "),n("p",[t._v("JS中Number类型使用"),n("code",[t._v("IEEE754")]),t._v("标准来表示整数和浮点数值。\n"),n("code",[t._v("IEEE754")]),t._v("："),n("strong",[t._v("全称IEEE二进制浮点数算术标准")]),t._v("，定义了表示浮点数的格式等内容。")]),t._v(" "),n("p",[t._v("所谓"),n("strong",[t._v("浮点数值")]),t._v("，就是该数值中必须包含"),n("strong",[t._v("一个小数点")]),t._v("，并且"),n("strong",[t._v("小数点后至少有一位数字")]),t._v("。\n浮点数值的"),n("strong",[t._v("最高精度是17位小数")]),t._v("。")]),t._v(" "),n("p",[t._v("在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、\n延伸单精确度、延伸双精确度。JS采用的就是"),n("strong",[t._v("双精确度")]),t._v("，也就是说，会用"),n("strong",[t._v("64位字节")]),t._v("来存储\n一个浮点数。")]),t._v(" "),n("h3",{attrs:{id:"深入浮点数精确度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深入浮点数精确度"}},[t._v("#")]),t._v(" 深入浮点数精确度")]),t._v(" "),n("p",[n("strong",[t._v("前言")])]),t._v(" "),n("p",[t._v("研究一下 0.1 + 0.2 是否等于 0.3")]),t._v(" "),n("p",[n("strong",[t._v("浮点数转二进制")])]),t._v(" "),n("p",[t._v("0.1 用二进制表示就是 0.00011001100110011……")]),t._v(" "),n("p",[n("strong",[t._v("浮点数的存储")])]),t._v(" "),n("p",[t._v("浮点数的储存是根据 "),n("em",[n("strong",[t._v("IEEE754规定")])]),t._v(" 的方式来存储的，这个标准方式有一个"),n("strong",[t._v("公式")]),t._v("来表示浮点数（Value）：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" Value = sign * exponent  * fraction\n")])])]),n("p",[t._v("简单理解就是"),n("strong",[t._v("科学计数法")])]),t._v(" "),n("p",[t._v("比如 -1020，用科学计数法表示就是:")]),t._v(" "),n("p",[n("code",[t._v("-1 * 10^3 * 1.02")])]),t._v(" "),n("p",[n("code",[t._v("-1")]),t._v(" 就是 sign， "),n("code",[t._v("10^3")]),t._v(" 就是 exponent， "),n("code",[t._v("1.02")]),t._v(" 就是 fraction")]),t._v(" "),n("p",[t._v("二进制也是一样，以 0.1 的二进制 0.00011001100110011…… 这个数来说")]),t._v(" "),n("p",[n("code",[t._v("1 * 2^-4 * 1.1001100110011……")])]),t._v(" "),n("p",[t._v("其中 sign 就是 1，exponent 就是 2^-4，fraction 就是 1.1001100110011……")]),t._v(" "),n("p",[t._v("而当只做二进制科学计数法的表示时，这个 Value 的表示可以再具体一点变成：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" V = (-1)^S * (1 + Fraction) * 2^E: \n")])])]),n("p",[n("strong",[t._v("(-1)^S")]),t._v(" 表示"),n("strong",[t._v("符号位")]),t._v("，当 S = 0，V 为正数；当 S = 1，V 为负数。")]),t._v(" "),n("p",[n("strong",[t._v("(1 + Fraction)")]),t._v("：因为所有的浮点数都可以表示为 "),n("strong",[t._v("1.xxxx * 2^xxx")]),t._v(" 的形式，所以1.xxxx 前面的一定是 1.xxx，就不存储这个 1 了，直接存后面的 xxxxx ，这也就是 Fraction 的部分。")]),t._v(" "),n("p",[n("strong",[t._v("2^E")]),t._v(": E "),n("strong",[t._v("既可能是负数，又可能是正数")]),t._v("，该怎么储存这个 E 呢？我们并不会直接存储 E，而是会存储 "),n("strong",[t._v("E + bias")]),t._v("。所以，存储一个浮点数，会存 S 和 Fraction 和 E + bias 这三个值，那具体要分配多少个字节位来存储这些数呢？IEEE754 给出了标准：")]),t._v(" "),n("p",[n("img",{attrs:{src:a(99),alt:"An image"}})]),t._v(" "),n("p",[t._v("在这个标准下：")]),t._v(" "),n("p",[t._v("用 1 位存储 S，0 表示正数，1 表示负数。")]),t._v(" "),n("p",[t._v("用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。")]),t._v(" "),n("p",[t._v("用 52 位存储 Fraction。")]),t._v(" "),n("p",[t._v("拿 0.1 来看，对应二进制科学计数法是 1 * 1.1001100110011…… * 2^-4，Sign 是 0，E + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，Fraction 是 1001100110011……")]),t._v(" "),n("p",[t._v("对应 64 个字节位的完整表示就是：")]),t._v(" "),n("p",[n("code",[t._v("0 01111111011 1001100110011001100110011001100110011001100110011010")])]),t._v(" "),n("p",[t._v("同理, 0.2 表示的完整表示是：")]),t._v(" "),n("p",[n("code",[t._v("0 01111111100 1001100110011001100110011001100110011001100110011010")])]),t._v(" "),n("p",[t._v("综上所述，浮点数在被存储的时候就已经丢失精度。")]),t._v(" "),n("p",[n("strong",[t._v("浮点数的运算")])]),t._v(" "),n("p",[t._v("浮点数的运算分为五个步骤："),n("strong",[t._v("对阶、尾数运算、规格化、舍入处理、溢出判断")])]),t._v(" "),n("p",[t._v("看一下0.1 + 0.2 的运算：")]),t._v(" "),n("p",[n("em",[n("strong",[t._v("对阶")])]),t._v(" ：把"),n("strong",[t._v("价码")]),t._v("调整为"),n("strong",[t._v("相同")]),t._v("，调整原则是小阶对大阶（即小的阶数调成大的阶数）。")]),t._v(" "),n("p",[t._v("比如：0.1的二进制科学计数法为 "),n("code",[t._v("1.1001100110011…… * 2^-4")]),t._v("，0.2的二进制科学计数法为 "),n("code",[t._v("1.10011001100110...* 2^-3")]),t._v("，0.1的"),n("strong",[t._v("价码")]),t._v("就是 "),n("code",[t._v("-4")]),t._v("，0.2的"),n("strong",[t._v("价码")]),t._v("就是 "),n("code",[t._v("-3")]),t._v("；再进行调整，把0.1的"),n("code",[t._v("-4")]),t._v("调整为"),n("code",[t._v("-3")]),t._v("即 "),n("code",[t._v("0.11001100110011…… * 2^-3")]),t._v("。")]),t._v(" "),n("p",[n("em",[n("strong",[t._v("尾数运算")])]),t._v("：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  0.1100110011001100110011001100110011001100110011001101 * 2^-3\n+ 1.1001100110011001100110011001100110011001100110011010 * 2^-3\n————————————————————————————————————————————————————————————————\n 10.0110011001100110011001100110011001100110011001100111 * 2^-3\n")])])]),n("p",[t._v("结果为 "),n("code",[t._v("10.0110011001100110011001100110011001100110011001100111 * 2^-3")])]),t._v(" "),n("p",[n("em",[n("strong",[t._v("规格化")])]),t._v("：")]),t._v(" "),n("p",[t._v("规格化结果为 "),n("code",[t._v("1.0011001100110011001100110011001100110011001100110011(1) * 2^-2")])]),t._v(" "),n("p",[t._v("括号里的 1 意思是计算后这个 1 超出了范围要被舍弃。")]),t._v(" "),n("p",[n("em",[n("strong",[t._v("舍入处理")])])]),t._v(" "),n("p",[t._v("四舍五入对应到二进制中，就是 0 舍 1 入，因为我们要把括号里的 1 丢了，所以这里会进一，结果变成")]),t._v(" "),n("p",[n("code",[t._v("1.0011001100110011001100110011001100110011001100110100 * 2^-2")])]),t._v(" "),n("p",[n("em",[n("strong",[t._v("结果")])])]),t._v(" "),n("p",[t._v("0.1 + 0.3 存成 64 位就是")]),t._v(" "),n("p",[n("code",[t._v("0 01111111101 0011001100110011001100110011001100110011001100110100")])]),t._v(" "),n("p",[t._v("将它转换为10进制数就得到")]),t._v(" "),n("p",[n("code",[t._v("0.30000000000000004440892098500626")])]),t._v(" "),n("p",[t._v("综上所述，因为0.1和0.2存储时的精度丢失再加上运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3")]),t._v(" "),n("h2",{attrs:{id:"类型检测"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类型检测"}},[t._v("#")]),t._v(" 类型检测")]),t._v(" "),n("h3",{attrs:{id:"检测基本类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#检测基本类型"}},[t._v("#")]),t._v(" 检测基本类型")]),t._v(" "),n("p",[t._v("检测变量的基本类型使用"),n("code",[t._v("typeof")]),t._v(",除了"),n("code",[t._v("null")]),t._v("都可以显示正确的类型。")]),t._v(" "),n("p",[t._v("使用"),n("code",[t._v("typeof")]),t._v("检查"),n("code",[t._v("null")]),t._v("值会返回"),n("code",[t._v("object")]),t._v("。因为从逻辑角度看，"),n("code",[t._v("null")]),t._v("表示一个空对象指针。")]),t._v(" "),n("p",[n("code",[t._v("typeof")]),t._v("检测函数时，会返回“function。")]),t._v(" "),n("h3",{attrs:{id:"检测引用类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#检测引用类型"}},[t._v("#")]),t._v(" 检测引用类型")]),t._v(" "),n("p",[t._v("检测变量的引用类型使用: "),n("code",[t._v("instanceof")]),t._v("。")]),t._v(" "),n("p",[t._v("检测某个对象是否为数组使用: "),n("code",[t._v("Array.isArray(obj)")])]),t._v(" "),n("h2",{attrs:{id:"类型转换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类型转换"}},[t._v("#")]),t._v(" 类型转换")]),t._v(" "),n("h3",{attrs:{id:"原始值转布尔"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原始值转布尔"}},[t._v("#")]),t._v(" 原始值转布尔")]),t._v(" "),n("p",[t._v("只有 6 种值可以被转换成 false，")]),t._v(" "),n("p",[t._v("不传任何参数时返回 false,")]),t._v(" "),n("p",[t._v("其他都会被转换成 true，")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v(" console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Boolean")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Boolean")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Boolean")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Boolean")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Boolean")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("NaN")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Boolean")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=v.exports},99:function(t,s,a){t.exports=a.p+"assets/img/ebais.2c508606.png"}}]);